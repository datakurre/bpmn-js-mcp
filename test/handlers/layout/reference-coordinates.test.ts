/**
 * Per-reference coordinate comparison tests.
 *
 * Reference BPMNs in test/fixtures/layout-references/ are generated by the
 * ELK layout engine (copied from layout-snapshots/). These tests verify
 * that the layout engine produces deterministic, identical positions when
 * re-importing and re-laying-out those same diagrams.
 *
 * Run with: npx vitest run test/handlers/layout/reference-coordinates.test.ts
 */

import { describe, test, expect, beforeEach } from 'vitest';
import { handleLayoutDiagram } from '../../../src/handlers';
import { clearDiagrams, importReference, comparePositions } from '../../helpers';

// ── Helpers ────────────────────────────────────────────────────────────────

/** Centre-Y of an element. */
function centreY(el: any): number {
  return el.y + (el.height || 0) / 2;
}

/** Centre-X of an element. */
function centreX(el: any): number {
  return el.x + (el.width || 0) / 2;
}

/**
 * Log position comparison results for debugging.
 * Called when mismatches exist.
 */
function logMismatches(name: string, result: ReturnType<typeof comparePositions>) {
  if (result.mismatches.length > 0) {
    console.error(`\n── Position mismatches (${name}) ──`);
    for (const m of result.mismatches) {
      console.error(
        `  ${m.elementId}: ref(${m.refX},${m.refY}) actual(${m.actualX},${m.actualY}) Δ(${m.dx},${m.dy})`
      );
    }
    console.error(
      `  Match rate: ${(result.matchRate * 100).toFixed(1)}% (${result.deltas.length - result.mismatches.length}/${result.deltas.length})`
    );
  }
}

// ── Tests ──────────────────────────────────────────────────────────────────

describe('Reference coordinate comparison', () => {
  beforeEach(() => {
    clearDiagrams();
  });

  // ── 01 Linear Flow (All Task Types) ──────────────────────────────────
  // Element IDs (from 01-linear-flow-all-task-types.bpmn):
  //   Start        = StartEvent
  //   UserTask1    = UserTask "Enter Order"
  //   ServiceTask1 = ServiceTask "Validate"
  //   ScriptTask1  = ScriptTask "Enrich Data"
  //   BRTask1      = BusinessRuleTask "Apply Rules"
  //   SendTask1    = SendTask "Send Confirmation"
  //   ManualTask1  = ManualTask "Pack Order"
  //   ReceiveTask1 = ReceiveTask "Await Pickup"
  //   End          = EndEvent

  describe('01-linear-flow-all-task-types', () => {
    test('all elements on same Y row', async () => {
      const { diagramId, registry } = await importReference('01-linear-flow-all-task-types');
      await handleLayoutDiagram({ diagramId });

      // IDs in left-to-right flow order
      const ids = [
        'Start',
        'UserTask1',
        'ServiceTask1',
        'ScriptTask1',
        'BRTask1',
        'SendTask1',
        'ManualTask1',
        'ReceiveTask1',
        'End',
      ];

      const elements = ids.map((id) => registry.get(id)).filter(Boolean);
      expect(elements.length).toBe(9);

      // All elements should be on the same Y row (within 5px)
      const refY = centreY(elements[0]);
      for (const el of elements) {
        expect(
          Math.abs(centreY(el) - refY),
          `${el.id} Y=${centreY(el)} not on row Y=${refY}`
        ).toBeLessThanOrEqual(5);
      }
    });

    test('uniform horizontal gaps between elements', async () => {
      const { diagramId, registry } = await importReference('01-linear-flow-all-task-types');
      await handleLayoutDiagram({ diagramId });

      const ids = [
        'Start',
        'UserTask1',
        'ServiceTask1',
        'ScriptTask1',
        'BRTask1',
        'SendTask1',
        'ManualTask1',
        'ReceiveTask1',
        'End',
      ];

      const elements = ids.map((id) => registry.get(id)).filter(Boolean);

      // Compute edge-to-edge gaps between consecutive elements
      const gaps: number[] = [];
      for (let i = 1; i < elements.length; i++) {
        const prevRight = elements[i - 1].x + (elements[i - 1].width || 0);
        const currLeft = elements[i].x;
        gaps.push(currLeft - prevRight);
      }

      // All gaps should be positive (left-to-right ordering)
      for (const gap of gaps) {
        expect(gap, 'Elements should not overlap horizontally').toBeGreaterThan(0);
      }

      // Log for debugging
      const mean = gaps.reduce((a, b) => a + b, 0) / gaps.length;
      const stdDev = Math.sqrt(gaps.reduce((sum, g) => sum + (g - mean) ** 2, 0) / gaps.length);
      console.error(
        `\n  01-linear-flow-all-task-types gaps: [${gaps.map((g) => g.toFixed(0)).join(', ')}] mean=${mean.toFixed(0)} stdDev=${stdDev.toFixed(1)}`
      );
    });

    test('positions match reference', async () => {
      const { diagramId, registry } = await importReference('01-linear-flow-all-task-types');
      await handleLayoutDiagram({ diagramId });

      const result = comparePositions(registry, '01-linear-flow-all-task-types', 10);
      logMismatches('01-linear-flow-all-task-types', result);

      expect(result.matchRate).toBe(1.0);
    });
  });

  // ── 02 Exclusive Gateway ─────────────────────────────────────────────
  // Element IDs (from 02-exclusive-gateway.bpmn):
  //   Start           = StartEvent
  //   ReviewTask      = UserTask "Review Request"
  //   GW_Split        = ExclusiveGateway "Approved?"
  //   ProcessApproval = ServiceTask "Process Approval"
  //   NotifyRejection = SendTask "Notify Rejection" (default/off-path)
  //   GW_Merge        = ExclusiveGateway (merge)
  //   End             = EndEvent

  describe('02-exclusive-gateway', () => {
    test('happy path elements on same Y row', async () => {
      const { diagramId, registry } = await importReference('02-exclusive-gateway');
      await handleLayoutDiagram({ diagramId });

      // Happy path: Start → ReviewTask → GW_Split → ProcessApproval → GW_Merge → End
      const happyIds = ['Start', 'ReviewTask', 'GW_Split', 'ProcessApproval', 'GW_Merge', 'End'];

      const elements = happyIds.map((id) => registry.get(id)).filter(Boolean);
      expect(elements.length).toBe(6);

      // Happy path elements should share same Y (within 5px)
      const refY = centreY(elements[0]);
      for (const el of elements) {
        expect(
          Math.abs(centreY(el) - refY),
          `${el.id} Y=${centreY(el)} not on happy path row Y=${refY}`
        ).toBeLessThanOrEqual(5);
      }
    });

    test('"Notify Rejection" below happy path', async () => {
      const { diagramId, registry } = await importReference('02-exclusive-gateway');
      await handleLayoutDiagram({ diagramId });

      const gateway = registry.get('GW_Split');
      const rejection = registry.get('NotifyRejection');

      // Rejection task should be below the gateway
      expect(centreY(rejection)).toBeGreaterThan(centreY(gateway) + 10);
    });

    test('positions match reference', async () => {
      const { diagramId, registry } = await importReference('02-exclusive-gateway');
      await handleLayoutDiagram({ diagramId });

      const result = comparePositions(registry, '02-exclusive-gateway', 10);
      logMismatches('02-exclusive-gateway', result);
      expect(result.matchRate).toBe(1.0);
    });
  });

  // ── 03 Parallel Gateway ──────────────────────────────────────────────
  // Element IDs (from 03-parallel-gateway.bpmn):
  //   Start            = StartEvent
  //   Fork             = ParallelGateway (fork)
  //   ChargePayment    = ServiceTask "Charge Payment"
  //   ReserveInventory = ServiceTask "Reserve Inventory"
  //   NotifyWarehouse  = ServiceTask "Notify Warehouse"
  //   Join             = ParallelGateway (join)
  //   ConfirmOrder     = UserTask "Confirm Order"
  //   End              = EndEvent

  describe('03-parallel-gateway', () => {
    test('three branches on distinct Y rows', async () => {
      const { diagramId, registry } = await importReference('03-parallel-gateway');
      await handleLayoutDiagram({ diagramId });

      const charge = registry.get('ChargePayment');
      const reserve = registry.get('ReserveInventory');
      const notify = registry.get('NotifyWarehouse');

      // All three branches should have distinct Y
      const ys = [centreY(charge), centreY(reserve), centreY(notify)];
      expect(new Set(ys.map((y) => Math.round(y / 10))).size).toBe(3);
    });

    test('positions match reference', async () => {
      const { diagramId, registry } = await importReference('03-parallel-gateway');
      await handleLayoutDiagram({ diagramId });

      const result = comparePositions(registry, '03-parallel-gateway', 10);
      logMismatches('03-parallel-gateway', result);
      expect(result.matchRate).toBe(1.0);
    });
  });

  // ── 04 Inclusive Gateway ─────────────────────────────────────────────
  // Element IDs (from 04-inclusive-gateway.bpmn):
  //   Start         = StartEvent
  //   ClassifyAlert = UserTask "Classify Alert"
  //   OR_Split      = InclusiveGateway (split)
  //   SendEmail     = ServiceTask "Send Email"
  //   SendSMS       = ServiceTask "Send SMS"
  //   SendPush      = ServiceTask "Send Push"
  //   OR_Join       = InclusiveGateway (join)
  //   LogNotification = ServiceTask "Log Notification"
  //   End           = EndEvent

  describe('04-inclusive-gateway', () => {
    test('three branches on distinct Y rows', async () => {
      const { diagramId, registry } = await importReference('04-inclusive-gateway');
      await handleLayoutDiagram({ diagramId });

      const email = registry.get('SendEmail');
      const sms = registry.get('SendSMS');
      const push = registry.get('SendPush');

      const ys = [centreY(email), centreY(sms), centreY(push)];
      expect(new Set(ys.map((y) => Math.round(y / 10))).size).toBe(3);
    });

    test('positions match reference', async () => {
      const { diagramId, registry } = await importReference('04-inclusive-gateway');
      await handleLayoutDiagram({ diagramId });

      const result = comparePositions(registry, '04-inclusive-gateway', 10);
      logMismatches('04-inclusive-gateway', result);
      expect(result.matchRate).toBe(1.0);
    });
  });

  // ── 06 Subprocess with Boundary Events ───────────────────────────────
  // Element IDs (from 06-subprocess-with-boundary-events.bpmn):
  //   Start         = StartEvent
  //   SubProcess1   = SubProcess (expanded)
  //   SubStart      = StartEvent (inner)
  //   ReviewClaim   = UserTask "Review Claim" (inner)
  //   ValidateClaim = ServiceTask "Validate Claim" (inner)
  //   ApproveClaim  = UserTask "Approve Claim" (inner)
  //   SubEnd        = EndEvent (inner)
  //   ErrorBoundary = BoundaryEvent (error, on SubProcess1)
  //   TimerBoundary = BoundaryEvent (timer, on SubProcess1)
  //   PayClaim      = ServiceTask "Pay Claim"
  //   HandleError   = UserTask "Handle Error"
  //   EscalateTask  = UserTask "Escalate"
  //   EndOK         = EndEvent
  //   EndError      = EndEvent
  //   EndEscalated  = EndEvent

  describe('06-subprocess-with-boundary-events', () => {
    test('inner elements left-to-right ordering preserved', async () => {
      const { diagramId, registry } = await importReference('06-subprocess-with-boundary-events');
      await handleLayoutDiagram({ diagramId });

      const subStart = registry.get('SubStart');
      const review = registry.get('ReviewClaim');
      const subEnd = registry.get('SubEnd');

      if (subStart && review && subEnd) {
        // Inner elements should maintain left-to-right ordering after layout
        expect(centreX(subStart), 'SubStart before ReviewClaim').toBeLessThan(centreX(review));
        expect(centreX(review), 'ReviewClaim before SubEnd').toBeLessThan(centreX(subEnd));
      }
    });

    test('positions match reference', async () => {
      const { diagramId, registry } = await importReference('06-subprocess-with-boundary-events');
      await handleLayoutDiagram({ diagramId });

      const result = comparePositions(registry, '06-subprocess-with-boundary-events', 10);
      logMismatches('06-subprocess-with-boundary-events', result);
      expect(result.matchRate).toBe(1.0);
    });
  });

  // ── 08 Boundary Events (All Types) ───────────────────────────────────
  // Element IDs (from 08-boundary-events-all-types.bpmn):
  //   Start          = StartEvent
  //   Task_Timer     = UserTask (host for timer boundary)
  //   BoundTimer     = BoundaryEvent (timer)
  //   Task_Error     = ServiceTask (host for error boundary)
  //   BoundError     = BoundaryEvent (error)
  //   Task_Message   = UserTask (host for message boundary)
  //   BoundMessage   = BoundaryEvent (message)
  //   Task_Signal    = ServiceTask (host for signal boundary)
  //   BoundSignal    = BoundaryEvent (signal)
  //   Task_Escalation = UserTask (host for escalation boundary)

  describe('08-boundary-events-all-types', () => {
    test('escalation path below main flow', async () => {
      const { diagramId, registry } = await importReference('08-boundary-events-all-types');
      await handleLayoutDiagram({ diagramId });

      const taskTimer = registry.get('Task_Timer');
      const boundTimer = registry.get('BoundTimer');

      if (taskTimer && boundTimer) {
        // Boundary event should be near the host element's bottom edge
        const hostBottom = taskTimer.y + (taskTimer.height || 0);
        expect(
          Math.abs(centreY(boundTimer) - hostBottom),
          'Boundary event should be near host bottom edge'
        ).toBeLessThan(50);
      }
    });

    test('positions match reference', async () => {
      const { diagramId, registry } = await importReference('08-boundary-events-all-types');
      await handleLayoutDiagram({ diagramId });

      const result = comparePositions(registry, '08-boundary-events-all-types', 30);
      logMismatches('08-boundary-events-all-types', result);
      expect(result.matchRate).toBeGreaterThanOrEqual(0.7);
    });
  });

  // ── 19 Complex Workflow Patterns ─────────────────────────────────────
  // Element IDs (from 19-complex-workflow-patterns.bpmn):
  //   Start           = StartEvent
  //   TimerStart      = StartEvent (timer)
  //   GW_Merge1       = ExclusiveGateway (merge after starts)
  //   ClassifyOrder   = UserTask "Classify Order"
  //   GW_OrderType    = ExclusiveGateway "Order Type?"
  //   GW_Fork1        = ParallelGateway (fork)
  //   CheckInventory  = ServiceTask "Check Inventory"
  //   CalculateShipping = ServiceTask "Calculate Shipping"
  //   GW_Join1        = ParallelGateway (join)
  //   ExpressProcess  = ServiceTask "Express Process"
  //   Sub_CustomProcess = SubProcess (collapsed)
  //   GW_FinalMerge   = ExclusiveGateway (final merge)
  //   FinalConfirm    = UserTask "Final Confirm"
  //   End             = EndEvent

  describe('19-complex-workflow-patterns', () => {
    test('rejection/express branches below happy path', async () => {
      const { diagramId, registry } = await importReference('19-complex-workflow-patterns');
      await handleLayoutDiagram({ diagramId });

      const inventory = registry.get('CheckInventory');
      const shipping = registry.get('CalculateShipping');
      const express = registry.get('ExpressProcess');

      if (inventory && shipping && express) {
        // Parallel branches should be on different Y
        expect(Math.abs(centreY(inventory) - centreY(shipping))).toBeGreaterThan(10);
      }
    });

    test('parallel branches between fork and join', async () => {
      const { diagramId, registry } = await importReference('19-complex-workflow-patterns');
      await handleLayoutDiagram({ diagramId });

      const fork = registry.get('GW_Fork1');
      const join = registry.get('GW_Join1');
      const inventory = registry.get('CheckInventory');
      const shipping = registry.get('CalculateShipping');

      expect(centreX(inventory)).toBeGreaterThan(centreX(fork));
      expect(centreX(inventory)).toBeLessThan(centreX(join));
      expect(centreX(shipping)).toBeGreaterThan(centreX(fork));
      expect(centreX(shipping)).toBeLessThan(centreX(join));
    });

    test('positions match reference', async () => {
      const { diagramId, registry } = await importReference('19-complex-workflow-patterns');
      await handleLayoutDiagram({ diagramId });

      const result = comparePositions(registry, '19-complex-workflow-patterns', 50);
      logMismatches('19-complex-workflow-patterns', result);
      expect(result.matchRate).toBeGreaterThanOrEqual(0.5);
    });
  });
});
